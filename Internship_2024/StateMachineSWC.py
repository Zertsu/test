# Tracks the current state of the robot and handles transitions

# Autogenerated code, DO NOT EDIT
from RTE import Rte_Read_StateMachineSWC_ui8_Control_bits, Rte_Read_StateMachineSWC_b_Emergency_distance, Rte_Read_StateMachineSWC_b_Emergency_timeout, Rte_Read_StateMachineSWC_b_Shoot, Rte_Read_StateMachineSWC_b_guarding_mode, Rte_Write_StateMachineSWC_E_State, Rte_Write_StateMachineSWC_b_Angle_reset, Rte_Write_StateMachineSWC_b_guarding_mode, Rte_Write_StateMachineSWC_ui16_motor_speed
# End of autogenerated code

import uasyncio as asyncio
from typedefs import States

# Initialize states
lastState = States.NONE
state = States.IDLE
nextState = States.IDLE


# Configuration
RUN_PERIOD = 50 # [ms] Run period of the state machine


# Definition of the control bits
class ControlBits():
    FORWARD = 1 << 0
    BACKWARD = 1 << 1
    LEFT = 1 << 2
    RIGHT = 1 << 3
    SHOOT = 1 << 4
    GUARDING = 1 << 6


# Check if entered the current state
def check_first_entry():
    return state != lastState


previousGuardingBit = False
# Checks for transitions from IDLE, considering the control and emergency bits
def checkTranitionNeeded_Idle():
    global lastState
    global state
    global nextState
    global previousGuardingBit

    # Variable tracking if we need to transittion
    transittionNeeded = False

    # Read relevant variables from the RTE
    controlBits = Rte_Read_StateMachineSWC_ui8_Control_bits()
    timeoutEmergency = Rte_Read_StateMachineSWC_b_Emergency_timeout()
    distanceEmergency = Rte_Read_StateMachineSWC_b_Emergency_distance()
    guardingBit = bool(controlBits & ControlBits.GUARDING)

    # In case of comunication timeout, don't change out of IDLE
    if timeoutEmergency:
        pass

    # If we're not in timeout we can go backwards
    elif controlBits & ControlBits.BACKWARD:
        nextState = States.GO_BACKWARD
        transittionNeeded = True
    
    # To do anything else we have to not be in a distance emergency
    elif distanceEmergency:
        pass
    
    # Change state acording to the control bits
    elif controlBits & ControlBits.FORWARD:
        nextState = States.GO_FORWARD
        transittionNeeded = True
    elif controlBits & ControlBits.LEFT:
        nextState = States.TURN_LEFT
        transittionNeeded = True
    elif controlBits & ControlBits.RIGHT:
        nextState = States.TURN_RIGHT
        transittionNeeded = True
    elif controlBits & ControlBits.SHOOT:
        nextState = States.SHOOT
        transittionNeeded = True
    elif not previousGuardingBit and guardingBit:
        # In case of guarding mode, enable the GuardingStateMachine,
        # and prepare to get the control back
        Rte_Write_StateMachineSWC_b_guarding_mode(True)
        lastState = States.NONE
        state = States.IDLE
        nextState = state
        transittionNeeded = True
    previousGuardingBit = guardingBit
    return transittionNeeded

 
# Checks transition out of SHOOT state, by looking for a fall transition on the Shoot bit
previousShootBit = True
shootBit = True
def checkTranitionNeeded_Shoot():
    global previousShootBit
    global shootBit
    global nextState
    previousShootBit = shootBit

    # Go back to IDLE state when the shoot bit transitions to False
    shootBit = Rte_Read_StateMachineSWC_b_Shoot()
    if previousShootBit and not shootBit:
        nextState = States.IDLE
        return True
    return False

# Checks if transition from a mooving state is needed, considering the
# control and emergency bits, the argument proveides the required control bit
# to stay in the current state
def checkTranitionNeeded_Mooving(mask):
    global nextState
    controlBits = Rte_Read_StateMachineSWC_ui8_Control_bits()
    emergency_distance = Rte_Read_StateMachineSWC_b_Emergency_distance()
    emergency_timeout = Rte_Read_StateMachineSWC_b_Emergency_timeout()
    
    # In case of an emergency go back to IDLE state
    if emergency_timeout:
        nextState = States.IDLE
        return True
    if emergency_distance and not (controlBits & ControlBits.BACKWARD):
        nextState = States.IDLE
        return True

    # When the desired bit becomes false in the controlBits go back to IDLE
    if not (controlBits & mask):
        nextState = States.IDLE
        return True
    return False


def guardingModeHandler():
    # In guarding mode hand over control to the GuardingStateMachine
    # and only check for emergencies and for manual disabling
    global previousGuardingBit

    timeoutEmergency = Rte_Read_StateMachineSWC_b_Emergency_timeout()
    distanceEmergency = Rte_Read_StateMachineSWC_b_Emergency_distance()
    if timeoutEmergency or distanceEmergency:
        guardingMode = False
        Rte_Write_StateMachineSWC_b_guarding_mode(guardingMode)
    
    controlBits = Rte_Read_StateMachineSWC_ui8_Control_bits()
    guardingBit = bool(controlBits & ControlBits.GUARDING)
    if guardingBit and not previousGuardingBit:
        # User disabled guarding mode
        guardingMode = False
        Rte_Write_StateMachineSWC_b_guarding_mode(guardingMode)
    previousGuardingBit = guardingBit
    

async def state_machine():
    global state
    global lastState
    global nextState
    nextState = state
    while True:
        guardingState = Rte_Read_StateMachineSWC_b_guarding_mode()
        if not guardingState:
            if state == States.IDLE:
                if(check_first_entry() == True):
                    pass # Do nothing
                else:
                    if(checkTranitionNeeded_Idle() == True):
                        pass # Do nothing
                    else :
                        pass # Do nothing
            
            elif state == States.GO_FORWARD:
                checkTranitionNeeded_Mooving(ControlBits.FORWARD)
            elif state == States.GO_BACKWARD:
                checkTranitionNeeded_Mooving(ControlBits.BACKWARD)
            elif state == States.TURN_LEFT:
                if(check_first_entry() == True):
                    Rte_Write_StateMachineSWC_b_Angle_reset(False)
                checkTranitionNeeded_Mooving(ControlBits.LEFT)
            elif state == States.TURN_RIGHT:
                if(check_first_entry() == True):
                    Rte_Write_StateMachineSWC_b_Angle_reset(False)
                checkTranitionNeeded_Mooving(ControlBits.RIGHT)
            elif state == States.SHOOT:
                if(check_first_entry() == True):
                    pass # Do nothing
                else:
                    if(checkTranitionNeeded_Shoot() == True):
                        pass # Do nothing
                    else :
                        pass # Do nothing

            lastState = state
            state = nextState

            Rte_Write_StateMachineSWC_E_State(state)
        else:
            guardingModeHandler()
        await asyncio.sleep_ms(RUN_PERIOD)
