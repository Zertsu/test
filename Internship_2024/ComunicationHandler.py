# Autogenerated code, DO NOT EDIT
from RTE import Rte_Read_ComunicationHandler_f_Distance, Rte_Write_ComunicationHandler_ui8_Control_bits, Rte_Write_ComunicationHandler_b_Control_bits_valid
# End of autogenerated code

import uasyncio as asyncio


import socket
import struct

# Configuration
BIND_ADDRESS = ("0.0.0.0", 15002) # Listening address for UDP socket
RECIEVE_RUN_PERIOD = 20 # [ms] Run period of the reciver component
SEND_RUN_PERIOD = 50 # [ms] Run period of the sender component
TIMEOUT_THRESHOLD = 1000 # [ms] Time after the connection is considered timed out


# Global Variables
lastPacketSender = ("0.0.0.0", 0)
udpSocket = None

# Packet type definitions
class PacketType():
    PING = 0
    PONG = 1
    CONTROL = 2
    DISTANCE = 3

async def ComunicationHandler_Recieve():
    global BIND_ADDRESS
    global RECIEVE_RUN_PERIOD
    global lastPacketSender
    global udpSocket

    # Setup UDP socket
    udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udpSocket.setblocking(False)
    udpSocket.bind(BIND_ADDRESS)

    # Initialize local variables
    timeSinceLastPacket = 0

    while True:
        try:
            packet, recvAddress = udpSocket.recvfrom(64)
            # print(packet)
            if packet:
                timeSinceLastPacket = 0
                lastPacketSender = recvAddress
                response = handlePacket(packet)
                if not response == None:
                    udpSocket.sendto(response, recvAddress)
        except OSError as e:
            timeSinceLastPacket = timeSinceLastPacket + RECIEVE_RUN_PERIOD
        
        isTimedOut = timeSinceLastPacket > TIMEOUT_THRESHOLD
        Rte_Write_ComunicationHandler_b_Control_bits_valid(isTimedOut)
        await asyncio.sleep_ms(RECIEVE_RUN_PERIOD)


def handlePacket(packet):
    packetType = packet[0]
    packetData = packet[1:]

    if packetType == PacketType.PING:
        # Ping packet, respond with PONG packet
        return struct.pack("!bb", PacketType.PONG, packetData[0])
    if packetType == PacketType.PONG:
        # Pong packet, do nothing
        return
    if packetType == PacketType.CONTROL:
        Rte_Write_ComunicationHandler_ui8_Control_bits(packetData[0])
        return


async def ComunicationHandler_Send():
    global SEND_RUN_PERIOD
    global udpSocket

    while True:
        if lastPacketSender[0] != "0.0.0.0":
            distance = Rte_Read_ComunicationHandler_f_Distance()
            packetData = struct.pack("!Bf", PacketType.DISTANCE, distance)
            udpSocket.sendto(packetData, lastPacketSender)
        await asyncio.sleep_ms(SEND_RUN_PERIOD)
        
