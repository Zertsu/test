# Autogenerated code, DO NOT EDIT
from RTE import Rte_Read_ComunicationHandler_f_Distance, Rte_Read_ComunicationHandler_b_guarding_mode, Rte_Write_ComunicationHandler_ui8_Control_bits, Rte_Write_ComunicationHandler_b_Control_bits_valid, Rte_Write_ComunicationHandler_S_face_position
# End of autogenerated code

import uasyncio as asyncio


import socket
import struct

# Logger
import Logger
log = Logger.Logger("Communication Handler")

# Configuration
BIND_ADDRESS = ("0.0.0.0", 15002) # Listening address for UDP socket
RECIEVE_RUN_PERIOD = 20 # [ms] Run period of the reciver component
SEND_RUN_PERIOD = 50 # [ms] Run period of the sender component
TIMEOUT_THRESHOLD = 1000 # [ms] Time after the connection is considered timed out
DISTANCE_SEND_PERIOD = 200 # [ms] Send period of the distance packet
STATE_SEND_PERIOD = 1000 # [ms] Send period of the state packet


# Global Variables
lastPacketSender = ("0.0.0.0", 0)
udpSocket = None
isTimedOut = True

# Packet type definitions
class PacketType():
    PING = 0
    PONG = 1
    CONTROL = 2
    DISTANCE = 3
    FACE_POSITION = 4
    STATE = 5

async def ComunicationHandler_Recieve():
    global BIND_ADDRESS
    global RECIEVE_RUN_PERIOD
    global lastPacketSender
    global udpSocket
    global isTimedOut

    log.LOGI("Starting Reciever")
    # Setup UDP socket
    udpSocket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udpSocket.setblocking(False)
    udpSocket.bind(BIND_ADDRESS)
    log.LOGI("Created and bound socket to {}".format(BIND_ADDRESS))

    # Initialize local variables
    timeSinceLastPacket = 0

    while True:
        try:
            packet, recvAddress = udpSocket.recvfrom(64)
            if packet:
                log.LOGD("Recieved packet from {}: {}".format(socket.inet_ntop(socket.AF_INET, recvAddress[4:]), packet))
                if isTimedOut:
                    log.LOGI("Timeout cleard")
                timeSinceLastPacket = 0
                isTimedOut = False
                lastPacketSender = recvAddress
                response = handlePacket(packet)
                if not response == None:
                    log.LOGD("Sending response to {}: {}".format(socket.inet_ntop(socket.AF_INET, recvAddress[4:]), response))
                    udpSocket.sendto(response, recvAddress)
        except OSError as e:
            timeSinceLastPacket = timeSinceLastPacket + RECIEVE_RUN_PERIOD
         
        if not isTimedOut and timeSinceLastPacket > TIMEOUT_THRESHOLD:
            log.LOGW("Connection timed out")
            isTimedOut = True
        Rte_Write_ComunicationHandler_b_Control_bits_valid(isTimedOut)
        await asyncio.sleep_ms(RECIEVE_RUN_PERIOD)
    log.LOGF("Reciever exited loop")


def handlePacket(packet):
    packetType = packet[0]
    packetData = packet[1:]

    if packetType == PacketType.PING:
        # Ping packet, respond with PONG packet
        return struct.pack("!bb", PacketType.PONG, packetData[0])
    if packetType == PacketType.PONG:
        # Pong packet, do nothing
        return
    if packetType == PacketType.CONTROL:
        Rte_Write_ComunicationHandler_ui8_Control_bits(packetData[0])
        return
    if packetType == PacketType.FACE_POSITION:
        facePosition = struct.unpack("<HHHHHHHHHHHHHHHH", packetData)
        Rte_Write_ComunicationHandler_S_face_position(facePosition)
        return


async def ComunicationHandler_Send():
    global SEND_RUN_PERIOD
    global udpSocket
    global isTimedOut

    log.LOGI("Starting sender")

    # Local variables
    lastGuardingState = Rte_Read_ComunicationHandler_b_guarding_mode()
    timeSinceLastStateReport = 0
    timeSinceLastDistanceReport = 0

    while True:
        # Only send packets if we have somewhere to send them to
        if not isTimedOut:
            if timeSinceLastDistanceReport >= DISTANCE_SEND_PERIOD:    
                # Send out distance measurement
                distance = Rte_Read_ComunicationHandler_f_Distance()
                packetData = struct.pack("!Bf", PacketType.DISTANCE, distance)
                udpSocket.sendto(packetData, lastPacketSender)
                timeSinceLastDistanceReport = 0
            else:
                timeSinceLastDistanceReport = timeSinceLastDistanceReport + SEND_RUN_PERIOD

            # Handle guard state sending
            guardingState = Rte_Read_ComunicationHandler_b_guarding_mode()
            if guardingState != lastGuardingState or timeSinceLastStateReport >= STATE_SEND_PERIOD:
                # Send out guarding mode state change
                packetData = struct.pack("!Bb", PacketType.STATE, guardingState)
                udpSocket.sendto(packetData, lastPacketSender)
                timeSinceLastStateReport = 0
            else:
                timeSinceLastStateReport = timeSinceLastStateReport + SEND_RUN_PERIOD

        
        await asyncio.sleep_ms(SEND_RUN_PERIOD)
    log.LOGF("Sender exited loop")
